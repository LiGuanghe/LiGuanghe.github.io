# 完整编程手册
## 引言

[视频](https://pan.baidu.com/s/1nvmMinR)(密码:p6i1)演示生成[20行代码](https://github.com/DebugUself/du4proto/blob/atl4dama/src/stdin0handlog.py),按时间线记录[800行笔记](https://github.com/liguanghe/liguanghe.github.io/blob/gh-pages/source/_drafts/ZQCodingNote.md). 高手对小白讲解了自己从一个需求到一个功能,不断拆解, 调试, 实现想法, 最后实现功能的思维和行为过程.

## 知识点

### 需求到功能, 想法如何拆解?
整个过程大概是这样的, 首先, 我有一个小想法,我想实现它, 于是我写一个 readme.md, 告诉我自己和同伴们, 我想实现这个功能. 前提是, 我要先告诉大家,我有什么. 我的环境是什么. 有什么, 要什么. 

在这个项目里面, 大妈有人可读的时间记录数据列表, 想变成机可读的. 为了实现这个目的, 大家不断在 README.md 里修改. 

写代码, 调试. 

过程如下: 
```
思路 - 需求 - 原始数据 - 开始打代码 - 代码结构 - 代码行 - 读代码 - 注释
|  \                                       |
背景知识 提问                              优雅代码
```

下面这张表是按照上面的内容逐条对比小白和高手的区别

type|小白|高手|学到
---|---|---|---
思路|不知道先干哪一步,理解项目要完全依赖 README,自己拿到原始数据无从下手, 没有思路|看到问题瞬间有200多个方法, 但不知道哪个有效.用思维工具把思维速度降下来. **定义清楚需求.用纸和笔把目的写下来,由果到因往回回溯.**|定义清楚需求, 写下思路. 
清楚需求|要转换成什么不知道|知道所有的变成秒,**知道最后输出的是什么样子** |知道计算机输出内容的一般样子, 以及特殊项目中的阶段性样貌.
对待原始数据的态度|只想到前两步,看到番茄钟的, 会认为没有必要就删掉. | **尽可能把有效数据全部转换出来,供下一步程序员使用.** 除非确定无用, 否则都要清洗. |充分利用所有数据, 全局考虑项目和组员.
写什么代码|**google 如何实现功能的代码, 学着写**, 举例:16-20行,看到把时间转成秒, 我也来写个脚本转秒,关键词是"yy",在标准库里面找, 没有找到.google 里面找,看到又现成的 app, 再搜这个关键词,不懂|**先看默认标准库和模块**.看最常见的 demo.|尊重源头知识, 到源头拿现成和核心的知识.
?|doc.python.org/ 下载到本地, 常用200个库, 经常看. 跟 time 有关的, 到默认库检索 time.(官方模块千锤百炼)
拆分功能在代码上的显现(代码结构)|用命令行一次打开一个脚本| **用命令行下的管道, 把一件事情拆分成不同的步骤.** 举例ls 的含义是把文件夹下面的文件打印出来, 加上条件,以 zq开头的参数,把每一行打印出来, 不用一个一个打. 用 python 处理.stdin0, 处理数据, 第二步处理 head, 第三步把时间转成秒, 第四部把番茄钟转换成秒. |拆分功能在代码上的显现, 不仅仅是脚本中不同的模块, 还包括管道串联. 脚本只解决一个小功能.
背景知识|没有常识, 不知道什么是良构. csv|没经历过, 就读官方文档|多看项目, 都看官方文档
提问|明知卡住了,不问, 搜索时间过长, 在 slack 上提问, 提问内容80%陈述猜想, 而不是事实|认真提问, 事实, 环境/现象/问题/分析/方案, 描述过程中会产生方案. 尝试方案, 走通, 走不通,都记下来.一个方案15分钟走不下去, 就停止. 走不下去的方案是因为问题没有描述清楚. 不知道自己要干什么, 别人也无法回答.|回归需求和功能. 所有的项目都严格限定在这两点之间. 
代码行|写一坨代码后再逐行调试|目前只写了四行代码, 调试五次(在命令行下面运行), 知道现在干嘛.| 不断调试,让计算机反馈结果 这里可见下面的三级标题: 需求到功能之间. 
优雅代码|```_s = l.split()   print('{},{}'.format(_s[0],_s[1]))```|```print (','.join(l.split()))```|简洁
写注释|改了什么|目的是什么,在调什么,用时, 要完成什么功能/探索.可以在git log 里很快的知道你做了什么事情.|仍然指向功能
读代码|从头开始读, 不懂|[1]|再一次的强调了功能和需求

[1]
代码是完成态,是线性的, 但读的形式和运行的次序是不同的.代码给出所有的通道,但是每行从哪个通道走, 你要清楚.

1. 搞清楚这个代码是为了解决什么问题, 这个问题有哪些子问题. 
2. 清楚代码结构.从大到小: 先调一类数据, 再调一类, 都好了以后调试全部. if else, 是代码里的分支, 每个分支是做什么的, 你要清楚. 根据理解一个分支, 其他的不处理. 代码每两三行解决一个问题.
3. 以上代码结构里的大大小小组块解决了什么问题? 
4. 读的具体方法
    1. ```#print``` 方便他人读你的代码,这是在反复验证你当时是怎么想的,怎么实现的. 不懂哪一行, 就去掉#, print你不懂的地方. 
    2. 可以把代码注释掉, 看不懂, 就注释掉它, 不让他运行, 看差别, 就知道代码是在做什么.这与查 bug的冷冻调试法和二分法是一样的.制造可控 bug 以理解改行代码的意义. 最终定位到行. 

### 需求到功能之间

- 拆解 -> 想法 -> 实现 -> 调试 -> 拆解 ... 最后实现整个功能. 
- 之前不断强调的 MVP, 输入 -> 处理 -> 输出.

```
   代码 -> print -> 结果 -> 符合 -> #print -> git ->  下一个小想法
     ~             |
     |             v
     <------------不符合
```

if else 是编程的本质, 让计算机在面临选择的时候, 知道怎么进行下去. 每个脚本里的最小样本: 

```
if xx():
    print ...
else:
    pass
```

不断调试好,被注释掉的 print:

```
if xx():
    #print ...
else:
    if yy():
    print ...
    else: 
        pass
        ...
```

这样不断增加 if else 的过程, 就是不断从小到大实现想法, 最终实现功能的过程. 

eg.[线性记录](https://github.com/liguanghe/liguanghe.github.io/blame/gh-pages/source/_drafts/ZQCodingNote.md)line 75 - 167



### 代码中 数字, 符号, 括号都是什么(待完成)

一切皆数字. 脚本里只有三样: 数字, 符号, 字母.

type|字母|符号|数字
---|---|---|---
作用|替换/指代|运算|替换/指代/标绘位置
例子|变量/def|+/[]|1/1/[-1]


know|what
---|---
yes| if else import  string print  变量 缩进4个空格 def class for..in..
no| . [] () 0 1 -1 

eg. 脚本里的数字和符号

- if 1! = len(sys.argv)
- l = line[:-1]
- isDATE = 0
- (i[0])
- 以下有什么区别? 
```print (i[:-1])```
```print (i[-1])```
```print (i[0])```

- is head:\n\t{}'.format(l)
- (','.join(l.split()))


## 心
这里,其实也是双关语呢, 小白到高手, 也是需求和功能啊. 一个小白, 最终的目的是成为高手. 所以, 你要知道最终呈现(高手的样子), 也要知道目前环境(自己的样子). 按照<集异璧>的写法, 这篇笔记跟那本书一样, 都是有双关语的. 我们以编程为例, 不断对比小白和高手的异同, 不断接近最终呈现. 这同时也是一个小白转变为高手的过程. 在这里统一了. 

沉迷学习, 无法自拔. 发布文章时的快乐, 我想这叫正向反馈, 当然, 你也可以说是嘚瑟. 


