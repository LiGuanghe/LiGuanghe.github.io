# 完整编程手册
## 引言

[视频](https://pan.baidu.com/s/1nvmMinR)(密码:p6i1)演示生成[20行代码](https://github.com/DebugUself/du4proto/blob/atl4dama/src/stdin0handlog.py),按时间线记录[800行笔记](https://github.com/liguanghe/liguanghe.github.io/blob/gh-pages/source/_drafts/ZQCodingNote.md). 高手对小白讲解了自己从一个需求到一个功能,不断拆解, 调试, 实现想法, 最后实现功能的思维和行为过程.

## 知识点

### 需求到功能, 想法如何拆解?
整个过程大概是这样的, 首先, 我有一个小想法,我想实现它, 于是我写一个 readme.md, 告诉我自己和同伴们, 我想实现这个功能. 前提是, 我要先告诉大家,我有什么. 我的环境是什么. 有什么, 要什么. 

在这个项目里面, 大妈有人可读的时间记录数据列表, 想变成机可读的. 为了实现这个目的, 大家不断在 README.md 里修改. 

写代码, 调试. 

过程如下: 
```
思路 - 需求 - 原始数据 - 开始打代码 - 代码结构 - 代码行 - 读代码 - 注释
|  \                                       |
背景知识 提问                              优雅代码
```

下面这张表是按照上面的内容逐条对比小白和高手的区别

type|小白|高手|学到
---|---|---|---
思路|不知道先干哪一步,理解项目要完全依赖 README,自己拿到原始数据无从下手, 没有思路|看到问题瞬间有200多个方法, 但不知道哪个有效.用思维工具把思维速度降下来. **定义清楚需求.用纸和笔把目的写下来,由果到因往回回溯.**|定义清楚需求, 写下思路. 
清楚需求|要转换成什么不知道|知道所有的变成秒,**知道最后输出的是什么样子** |知道计算机输出内容的一般样子, 以及特殊项目中的阶段性样貌.
对待原始数据的态度|只想到前两步,看到番茄钟的, 会认为没有必要就删掉. | **尽可能把有效数据全部转换出来,供下一步程序员使用.** 除非确定无用, 否则都要清洗. |充分利用所有数据, 全局考虑项目和组员.
写什么代码|**google 如何实现功能的代码, 学着写**, 举例:16-20行,看到把时间转成秒, 我也来写个脚本转秒,关键词是"yy",在标准库里面找, 没有找到.google 里面找,看到又现成的 app, 再搜这个关键词,不懂|**先看默认标准库和模块**.看最常见的 demo.|尊重源头知识, 到源头拿现成和核心的知识.
?|doc.python.org/ 下载到本地, 常用200个库, 经常看. 跟 time 有关的, 到默认库检索 time.(官方模块千锤百炼)
拆分功能在代码上的显现(代码结构)|用命令行一次打开一个脚本| **用命令行下的管道, 把一件事情拆分成不同的步骤.** 举例ls 的含义是把文件夹下面的文件打印出来, 加上条件,以 zq开头的参数,把每一行打印出来, 不用一个一个打. 用 python 处理.stdin0, 处理数据, 第二步处理 head, 第三步把时间转成秒, 第四部把番茄钟转换成秒. |拆分功能在代码上的显现, 不仅仅是脚本中不同的模块, 还包括管道串联. 脚本只解决一个小功能.
背景知识|没有常识, 不知道什么是良构. csv|没经历过, 就读官方文档|多看项目, 都看官方文档
提问|明知卡住了,不问, 搜索时间过长, 在 slack 上提问, 提问内容80%陈述猜想, 而不是事实|认真提问, 事实, 环境/现象/问题/分析/方案, 描述过程中会产生方案. 尝试方案, 走通, 走不通,都记下来.一个方案15分钟走不下去, 就停止. 走不下去的方案是因为问题没有描述清楚. 不知道自己要干什么, 别人也无法回答.|回归需求和功能. 所有的项目都严格限定在这两点之间. 
代码行|写一坨代码后再逐行调试|目前只写了四行代码, 调试五次(在命令行下面运行), 知道现在干嘛.| 不断调试,让计算机反馈结果 这里可见下面的三级标题: 需求到功能之间. 
优雅代码|```_s = l.split()   print('{},{}'.format(_s[0],_s[1]))```|```print (','.join(l.split()))```|简洁
写注释|改了什么|目的是什么,在调什么,用时, 要完成什么功能/探索.可以在git log 里很快的知道你做了什么事情.|仍然指向功能
读代码|从头开始读, 不懂|[1]|再一次的强调了功能和需求

[1]
代码是完成态,是线性的, 但读的形式和运行的次序是不同的.代码给出所有的通道,但是每行从哪个通道走, 你要清楚.

1. 搞清楚这个代码是为了解决什么问题, 这个问题有哪些子问题. 
2. 清楚代码结构.从大到小: 先调一类数据, 再调一类, 都好了以后调试全部. if else, 是代码里的分支, 每个分支是做什么的, 你要清楚. 根据理解一个分支, 其他的不处理. 代码每两三行解决一个问题.
3. 以上代码结构里的大大小小组块解决了什么问题? 
4. 读的具体方法
    1. ```#print``` 方便他人读你的代码,这是在反复验证你当时是怎么想的,怎么实现的. 不懂哪一行, 就去掉#, print你不懂的地方. 
    2. 可以把代码注释掉, 看不懂, 就注释掉它, 不让他运行, 看差别, 就知道代码是在做什么.这与查 bug的冷冻调试法和二分法是一样的.制造可控 bug 以理解改行代码的意义. 最终定位到行. 

### 需求到功能之间

- 拆解 -> 想法 -> 实现 -> 调试 -> 拆解 ... 最后实现整个功能. 
- 之前不断强调的 MVP, 输入 -> 处理 -> 输出.

```
   代码 -> print -> 结果 -> 符合 -> #print -> git ->  下一个小想法
     ~             |
     |             v
     <------------不符合
```

if else 是编程的本质, 让计算机在面临选择的时候, 知道怎么进行下去. 每个脚本里的最小样本: 

```
if xx():
    print ...
else:
    pass
```

不断调试好,被注释掉的 print:

```
if xx():
    #print ...
else:
    if yy():
    print ...
    else: 
        pass
        ...
```

这样不断增加 if else 的过程, 就是不断从小到大实现想法, 最终实现功能的过程. 

eg.[线性记录](https://github.com/liguanghe/liguanghe.github.io/blame/gh-pages/source/_drafts/ZQCodingNote.md)line 75 - 167



### 代码中 数字, 符号, 括号都是什么(待完成)

一切皆数字. 脚本中的基本元素: 数字, 符号, 字母.

[Py101-004/basic element and grammer of python.ipynb at master · liguanghe/Py101-004](https://github.com/liguanghe/Py101-004/blob/master/Chap0/note/basic%20element%20and%20grammer%20of%20python.ipynb)

由它们组成基本元素和语法

know|what
---|---
yes| if else import  string print  变量 缩进4个空格 def class for..in..
no| . [] () 0 1 -1 

eg. 脚本里的数字和符号

- if 1! = len(sys.argv)
- l = line[:-1]
- isDATE = 0
- (i[0])
- 以下有什么区别? 
```print (i[:-1])```
```print (i[-1])```
```print (i[0])```

- is head:\n\t{}'.format(l)
- (','.join(l.split()))



## 心
这里,其实也是双关语呢, 小白到高手, 也是需求和功能啊. 一个小白, 最终的目的是成为高手. 所以, 你要知道最终呈现(高手的样子), 也要知道目前环境(自己的样子). 按照<集异璧>的写法, 这篇笔记跟那本书一样, 都是有双关语的. 我们以编程为例, 不断对比小白和高手的异同, 不断接近最终呈现. 这同时也是一个小白转变为高手的过程. 在这里统一了.

高手是我的需求, 我先把他转化成功能, 再把自己的现状转化成原始数据, 拆解功能, 逐个完成,不断趋近目标.  

沉迷学习, 无法自拔. 发布文章时的快乐, 我想这叫正向反馈, 当然, 你也可以说是嘚瑟. 

## 怼友反馈
- (大妈)

小白|高手
---|---
每次都上网现查|本地化
不完整看官网|看官方的外链
不写教程|写教程的技巧[1]

[1] 
- 每个人都必须写教程, 把自己的思路串起来. 
    - 知识是相同的, 大家最后达成也相同.
    - 每个人不同, 每人中间要翻越的概念重组次数(跨过认知障碍)也不相同. 举例, 小白要重建很多层概念. 要一一对应 python 的形式, 要完成编程意义的重构. 每人要跨过的认知障碍都不同.
    - 突破认知障碍之前和之后也都不同, 
    - 通过私人笔记记录, 跨之前的状态,摸索途径, 跨过之后的状态.
    - 摸索途径是 MVP, 每个想法都有输入和输出佐证. 逻辑分支之后再打印出来, 才能明确代码是对还是错. 脚本语言可以随时打印出来. 编译就不同了, 要看运行期才能看, 调试更费力. 这些体验要自己尝试.
 
- (珍教) 工整巧思完备的笔记作者问出如此基础的编程问题, 让人从根本上质疑这份笔记是否有用. 小鹤参加过 py103, 也在大妈项目组中两个月, 为什么连最基础的语法还不知道. 是哪里出了问题, 是学习方式有漏洞么?
    - (小鹤)在 py103 的时候初次接触编程, 被大量的官方文档吓住. 前三周的作业都是抄同学的代码, 勉强完成.第四周就完全做不出来了. 那时的心气不足, 也就是仍旧会假想困难, 拒绝面对, 不懂求助等等. 这些都是在怼圈慢慢矫正过来的. 真的如大妈所说, 每人要翻越的无门大山都不同. 对你很容易的编程基本知识, 恰好是我不想去查阅的, 因为我'假想'它会很难, 所以'不想'去查. 但是在怼圈里就不同了. 大妈会不断鼓励. 能明确感觉到大妈的黑客生活方式, 编程是其中的一部分, 但在不会编程具体语言之前, 能不能用黑客的思维生活呢? 我在怼圈的最大收获是, 即使截止目前为止, 我还不会一些基础的编程语法. 但是, 我已经有了以上笔记所体现出来的问题拆解思路, 需求到功能再到代码转换. 这篇笔记是很好的例子. 
    - (大妈)很简单, 代码写的少. 不写代码纯粹玩概念, 大家都可以把事情说的很清楚, 上手写代码才知道自己什么都不会. 编程知易行难, 编程是要求实践. 编程语言和框架进步, 接近自然语言, 你可以通过代码来约定形式. 产品经理不会编程但可以做好的产品经理. 概念说的清, 与程序员聊的下去. 上手写就会发现很多问题. 自然语言再接近也不同, 机器语言无法忍受模糊和逻辑混乱, 是严格逻辑自洽的. 是非自然的思维情况. 多实践, 立刻写代码. 
    - (诗颖)小问题, 查阅, 不知道函数意义, 就写个变量打印出来即可. 
    - (明星)Python的字符串处理部分，《Python编程快速上手—让繁琐工作自动化》里有详细解答.
- (大妈)每次怼周会的内容应出现在怼周刊,吸引大家参加怼周会.  

## 其他资源
http://openmindclub.qiniucdn.com/res/tr/tr_MDP2py4w_1_w1cli_rebuild.html
http://openmindclub.qiniucdn.com/res/tr/tr_MDP2py4w_1_w1cli_rebuild.html
http://openmindclub.qiniucdn.com/res/tr/tr_MDP2py4w_1_w1cli_rebuild.html
相关的过程性习惯都包含在各种公开的代码规范文档中: [The Pocoo Style Guide — Pocoo](http://www.pocoo.org/internal/styleguide/)
